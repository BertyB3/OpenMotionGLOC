/*
  G-LOC Motion Platform Controller - Version 43
  ------------------------------------------------
  Developed for a custom-built motion platform replicating the seat motion of 
  Sega's G-LOC arcade cabinet. This Arduino Mega 2560 code interfaces with a pair
  of DC motors using rotary encoders, limit switches, and PID control to simulate 
  pitch and roll motion during gameplay.

  LICENSE & USAGE
  ------------------------------
  This code is released for **personal, educational, and non-commercial use only**.
  You are free to modify and share this code for non-commercial purposes, provided that
  you retain this notice and credit the original author (Luke McMillan) in any derivatives.
  Commercial use, distribution, or sale of this software or derivative works is **NOT PERMITTED**
  without written permission from the author.
  See LICENSE.txt for full terms.

  CITATION
  ------------------------------
  If you use or build upon this project, please credit the original author:
    Luke McMillan (https://github.com/BertyB3/OpenMotionGLOC)
  and link back to the GitHub repository.

  DISCLAIMER – USE AT YOUR OWN RISK
  ---------------------------------------------
  This software is provided "as is" and WITHOUT ANY WARRANTY of any kind, express or implied.
  Working with high-powered motors and mains-powered devices is inherently dangerous.
  You are solely responsible for your own safety and any damage, injury, or loss resulting
  from the use or misuse of this software or associated hardware. By using this code,
  you agree to accept all risks and liabilities.

  CURRENTLY WORKING FEATURES:
  ------------------------------
  • Calibration on startup using limit switches and encoder readings
  • Live motor position tracking (mapped 1–32 scale)
  • PID-controlled movement based on target positions from MAME Hooker
  • Test Mode with manual control and OLED feedback
  • Serial timeout fallback to neutral position
  • Relay control for `start_lamp` and `danger_lamp` signals from MAME Hooker
  • OLED screen showing:
     - Target and mapped positions
     - PID output
     - Motor movement status
     - PWM values sent to each motor
     - Serial connection status
     - Lamp relay states (ON/OFF)

  EXPECTED SERIAL COMMANDS FROM MAMEHOOKER:
  --------------------------------------------
  • Q##   - Set left motor target position
  • R##   - Set right motor target position
  • S##   - Set left motor speed scalar (1–7)
  • T##   - Set right motor speed scalar (1–7)
  • A0/1  - Toggle `start_lamp` relay OFF/ON
  • B0/1  - Toggle `danger_lamp` relay OFF/ON
  • All commands must end with 'x' as delimiter

  TEST MODE:
  -------------
  • Triggered at startup via dedicated switch
  • Allows manual forward/reverse motor testing
  • OLED shows button states, encoder values, and limit switch status

  NEW FEATURES IN V43:
  ----------------------------
  MOTOR CONTROL IMPROVEMENTS:
  • Fixed motor polarity issues causing incorrect startup positioning
  • Improved direction mapping logic to correctly handle encoder-to-position conversions
  • Enhanced limit switch safety with proper directional awareness during movement
  • New emergencyLimitRecovery() function automatically backs motors off limit switches
  • Improved safeMoveMotorPWM() function with better polarity awareness and limit checking
  • Updated motor backoff logic that correctly moves away from triggered limits
  • Enhanced limit switch handling prevents motors from driving into limits during operation

  EMERGENCY STOP & SAFETY ENHANCEMENTS:
  • Dual recovery methods: E-Stop can now be cleared either by:
     - Serial "Start Lamp" command (A1) - automatic recovery
     - Manual SPEED button press - immediate manual recovery
  • Improved E-Stop state management with eStopLatched and waitForStartLamp flags
  • Better E-Stop feedback on OLED display showing current state and recovery options
  • Non-blocking boundary sensor logic that doesn't freeze the system
  • New boundary state tracking with boundaryHandlingActive and timing variables
  • Improved boundary recovery process with clear user feedback
  • Better integration between boundary sensor and normal motor operations

  NEW SAFETY FUNCTIONS:
  • waitForResumeButton() - provides user control for resuming operation after safety events
  • handleBoundarySensorActive() - manages active boundary sensor conditions
  • handleBoundarySensorCleared() - handles recovery when boundary sensor clears
  • Enhanced safety lockouts prevent unwanted motor movement during emergency conditions

  Author: Luke McMillan
  bertybeatle@gmail.com
  Date: June 2025
*/

#include <SPI.h>
#include <Adafruit_GFX.h>
#include <Adafruit_ST7735.h>
#include <PID_v1.h>
#include <EEPROM.h>

// --------- PIN ASSIGNMENTS ---------
#define TFT_CS    22
#define TFT_DC    26
#define TFT_RST   24
Adafruit_ST7735 tft = Adafruit_ST7735(TFT_CS, TFT_DC, TFT_RST);

// ----------Settings Mode Variables to be Stored in EPROM-------------
#define ADDR_KpQ 0
#define ADDR_KiQ 4
#define ADDR_KdQ 8
#define ADDR_KpR 12
#define ADDR_KiR 16
#define ADDR_KdR 20
#define ADDR_minPWMQ 24
#define ADDR_maxPWMQ 28
#define ADDR_minPWMR 32
#define ADDR_maxPWMR 36
#define ADDR_emergencyStop 40
#define ADDR_boundarySensorEnabled 50
#define ADDR_cabinEStopEnabled 51

//Helpers for Settings Mode
void saveSettings();
void loadSettings();

//Access to Settings Mode
const int settingsModeSwitchPin = 6;  // New settings switch

//Variables for Settings Mode
float minPWMQ = 80, maxPWMQ = 255;
float minPWMR = 80, maxPWMR = 255;

// Also KpR, KiR, KdR if you want them separate from Q
float KpR = 22.0, KiR = 3.5, KdR = 0.6; // etc

// For cursor tracking in Test Mode
const int numSettings = 13; // 5 per motor + emergency toggle
int cursorPos = 0;

//Left Motor Setup
const int motorQDirectionPin = 10;  // Left motor DIR
const int motorQSpeedPin     = 8;   // Left motor PWM
const int motorQLowerLimitPin = 3;
const int motorQUpperLimitPin = 2;
const int potMotorQPin = A0; // Not used in this version of the program,
const int motorQEnablePin = 12;     // Enable pin for Left motor (active LOW)

//Right Motor Setup
const int motorRDirectionPin = 11;  // Right motor DIR
const int motorRSpeedPin     = 9;   // Right motor PWM
const int motorRLowerLimitPin = 5;
const int motorRUpperLimitPin = 4;
const int potMotorRPin = A1; // Not used in this version of the program
const int motorREnablePin = 13;     // Enable pin for Right motor (active LOW)

//Rotary Encoder Setup
long encoderQMin = 0, encoderQMax = 0;
long encoderRMin = 0, encoderRMax = 0;
bool calibrationSuccessful = false;

//Booleans for the lamps
bool startLampState = false;
bool dangerLampState = false;

//Lamp assignments
const int startLampRelayPin = 40;   
const int dangerLampRelayPin = 41;  

//Emergenc Stop Code variables - not the generic emergencyStopEnabled and emergencyStopActive are not actively used in v41. 
bool emergencyStopEnabled = false;  
bool emergencyStopActive = false;
bool boundarySensorEnabled = true;
bool cabinEStopEnabled = true;
bool eStopLatched = false;          // Set true after E-Stop, false after recovery
bool waitForStartLamp = false;      // Set true after E-Stop, cleared after A1/StartLamp is triggered
bool boundaryActive = false;        // Set true if handling boundary recovery


// For detecting motion activity:
bool motionActive = false;
// new for V42
bool boundaryHandlingActive = false;
bool boundaryRecenteringComplete = false;
unsigned long boundaryTriggerTime = 0;

//Emergency Stop Pins
const int estopButtonPin = 25;      // E-stop button in cabin
const int boundarySensorPin = 27; // Use digital pin 27 for boundary sensor

// PID variables
double inputQ, outputQ, setpointQ;
double inputR, outputR, setpointR;

// PID tuning parameters (adjust as needed)
double Kp = 2.0, Ki = 0.5, Kd = 0.1;

// PID instances
PID pidQ(&inputQ, &outputQ, &setpointQ, Kp, Ki, Kd, DIRECT);
PID pidR(&inputR, &outputR, &setpointR, Kp, Ki, Kd, DIRECT);

//Helper Function for Motor Polarity (updated in v43)
bool getCorrectedDirection(bool moveToLowerPositions, bool isReversed) {
  // moveToLowerPositions = true means moving toward position 1 (upper limit)
  // moveToLowerPositions = false means moving toward position 32 (lower limit)
  
  // Apply polarity correction if needed
  return isReversed ? !moveToLowerPositions : moveToLowerPositions;
}

#define DEBUG false  // Enables/disables debug output

int motorPosQ = 16;
int motorPosR = 16;
int motorSpeedQ = 1;
int motorSpeedR = 1;

unsigned long lastSerialDataTime = 0;
const unsigned long serialTimeout = 5000;  // 5 second timeout

// Test & Setting Mode pins
const int testModeSwitchPin   = 14;
const int testLeftFwdPin      = 15;
const int testLeftRevPin      = 31;
const int testRightFwdPin     = 17;
const int testRightRevPin     = 34;
const int testSpeedButtonPin  = 33;

// Add if missing
bool motorQPolarityReversed = false;
bool motorRPolarityReversed = false;

//Rotary Encoder Directions
volatile bool encoderQDirectionForward = true;
volatile bool encoderRDirectionForward = true;

//Rotary Encoder Positions
volatile long encoderQPosition = 0;
volatile long encoderRPosition = 0;

float rpmLeft = 0;
float rpmRight = 0;

//Motor Encoder Wheels
const int encoderQPinA = 18;  // Left motor (Q) - Signal A
const int encoderQPinB = 19;  // Left motor (Q) - Signal B
const int encoderRPinA = 20;  // Right motor (R) - Signal A
const int encoderRPinB = 21;  // Right motor (R) - Signal B

const int EEPROM_RPM_LEFT_ADDR = 8;
const int EEPROM_RPM_RIGHT_ADDR = 12;

const bool DIR_FORWARD = true;
const bool DIR_REVERSE = false;

// --------- GLOBALS ---------
unsigned long lastDisplayUpdate = 0;
const unsigned long displayUpdateInterval = 200;  // ms

int testSpeedSetting = 4; // Start at mid-speed (1-7)
bool emergencyStopActivated = false;
String lastLines[16];

// --------- OLED HELPER ---------
void drawLine(int line, const String &text) {
  int y = line * 8;
  if (text != lastLines[line]) {
    tft.fillRect(0, y, 160, 8, ST7735_BLACK);
    tft.setCursor(0, y);
    tft.print(text);
    lastLines[line] = text;
  }
}
void clearAllLines() {
  for (int i = 0; i < 16; ++i) {
    lastLines[i] = "";
    tft.fillRect(0, i * 8, 160, 8, ST7735_BLACK);
  }
}

//Motor Encoder Wheels
void countEncoderQ() {
  bool bState = digitalRead(encoderQPinB);
  encoderQDirectionForward = !bState;  // true = forward, false = reverse
  encoderQPosition += encoderQDirectionForward ? 1 : -1;
}

void countEncoderR() {
  bool bState = digitalRead(encoderRPinB);
  encoderRDirectionForward = !bState;
  encoderRPosition += encoderRDirectionForward ? 1 : -1;
}

//New Function in v42 to address motor polarity issues. 
void moveMotorWithPolarity(int dirPin, int speedPin, bool moveUp, int speedPercent, bool isLeftMotor) {
  bool reversed = isLeftMotor ? motorQPolarityReversed : motorRPolarityReversed;
  bool correctedDir = getCorrectedDirection(moveUp, reversed);
  digitalWrite(dirPin, correctedDir ? HIGH : LOW);
  int pwmValue = map(constrain(speedPercent, 0, 100), 0, 100, 0, 255);
  analogWrite(speedPin, pwmValue);
}

// --------- DEBOUNCE HELPER ---------
bool debounceRead(int pin) {
  static unsigned long lastDebounce[40] = {0};
  static bool lastState[40] = {HIGH};
  int idx = pin;
  bool reading = digitalRead(pin);

  if (reading != lastState[idx]) {
    lastDebounce[idx] = millis();
  }
  if ((millis() - lastDebounce[idx]) > 5) {
    lastState[idx] = reading;
  }
  return lastState[idx] == LOW;
}

// --------- BASIC MOTOR CONTROL ---------
void stopMotor(int speedPin) {
  analogWrite(speedPin, 0);
}
void moveMotor(int dirPin, bool direction, int speedPercent, int speedPin) {
  digitalWrite(dirPin, direction ? HIGH : LOW);
  int pwmValue = map(constrain(speedPercent, 0, 100), 0, 100, 0, 255);
  analogWrite(speedPin, pwmValue);
}
void incrementTestSpeed() {
  testSpeedSetting++;
  if (testSpeedSetting > 7) testSpeedSetting = 1;
}

//new function in V43 to better handle motor polarity if and when a limit switch is hit.
void emergencyLimitRecovery() {
  // Check if any motor is stuck on a limit and force it off
  
  // Left motor recovery
  if (digitalRead(motorQLowerLimitPin) == HIGH) {
    Serial.println("Emergency: Q motor stuck on lower limit, backing off...");
    bool backoffDir = getCorrectedDirection(true, motorQPolarityReversed);
    moveMotor(motorQDirectionPin, backoffDir, 40, motorQSpeedPin);
    delay(200);
    stopMotor(motorQSpeedPin);
  }
  
  if (digitalRead(motorQUpperLimitPin) == HIGH) {
    Serial.println("Emergency: Q motor stuck on upper limit, backing off...");
    bool backoffDir = getCorrectedDirection(false, motorQPolarityReversed);
    moveMotor(motorQDirectionPin, backoffDir, 40, motorQSpeedPin);
    delay(200);
    stopMotor(motorQSpeedPin);
  }
  
  // Right motor recovery  
  if (digitalRead(motorRLowerLimitPin) == HIGH) {
    Serial.println("Emergency: R motor stuck on lower limit, backing off...");
    bool backoffDir = getCorrectedDirection(true, motorRPolarityReversed);
    moveMotor(motorRDirectionPin, backoffDir, 40, motorRSpeedPin);
    delay(200);
    stopMotor(motorRSpeedPin);
  }
  
  if (digitalRead(motorRUpperLimitPin) == HIGH) {
    Serial.println("Emergency: R motor stuck on upper limit, backing off...");
    bool backoffDir = getCorrectedDirection(false, motorRPolarityReversed);
    moveMotor(motorRDirectionPin, backoffDir, 40, motorRSpeedPin);
    delay(200);
    stopMotor(motorRSpeedPin);
  }
}

//Revised in V43 to properly account for motor direction. 
void safeMoveMotorPWM(
  int dirPin,
  int speedPWM,
  bool direction,      // true = forward (up), false = reverse (down)
  int speedPin,
  int upperLimitPin,
  int lowerLimitPin,
  bool isLeftMotor     // Add this parameter to know which motor
) {
  bool reversed = isLeftMotor ? motorQPolarityReversed : motorRPolarityReversed;
  
  // Check limits BEFORE moving - with polarity awareness
  if (direction) { // Trying to move UP
    // If we're trying to move up, check if upper limit is already triggered
    if (digitalRead(upperLimitPin) == HIGH) {
      stopMotor(speedPin);
      
      // If we're stuck on upper limit, force movement away
      bool backoffDir = getCorrectedDirection(false, reversed); // Move down to get off upper limit
      digitalWrite(dirPin, backoffDir ? HIGH : LOW);
      analogWrite(speedPin, 30); // Gentle backoff
      delay(50);
      stopMotor(speedPin);
      return;
    }
  } else { // Trying to move DOWN
    // If we're trying to move down, check if lower limit is already triggered
    if (digitalRead(lowerLimitPin) == HIGH) {
      stopMotor(speedPin);
      
      // If we're stuck on lower limit, force movement away
      bool backoffDir = getCorrectedDirection(true, reversed); // Move up to get off lower limit
      digitalWrite(dirPin, backoffDir ? HIGH : LOW);
      analogWrite(speedPin, 30); // Gentle backoff
      delay(50);
      stopMotor(speedPin);
      return;
    }
  }
  
  // Safe to move - apply polarity correction
  bool correctedDir = getCorrectedDirection(direction, reversed);
  digitalWrite(dirPin, correctedDir ? HIGH : LOW);
  analogWrite(speedPin, constrain(speedPWM, 0, 255));
}

// Boundary Sensor Handler
void handleBoundarySensorTriggered(bool inCalibration) {
  stopMotor(motorQSpeedPin);
  stopMotor(motorRSpeedPin);

  motorPosQ = 16;
  motorPosR = 16;

  clearAllLines();
  if (inCalibration) {
    drawLine(0, "Boundary Sensor");
    drawLine(1, "Blocked!");
    while (digitalRead(boundarySensorPin) == LOW) delay(100);
    clearAllLines();
    drawLine(0, "Boundary Clear!");
    delay(1000);
  } else {
    drawLine(0, "Boundary Triggered!");
    drawLine(1, "Recentering...");
    moveToCenter();

    // Set targets again for safety
    motorPosQ = 16;
    motorPosR = 16;

    clearAllLines();
    drawLine(0, "Boundary Clear!");
    drawLine(1, "Press SPEED Btn");
    drawLine(2, "to resume motion");
    waitForResumeButton();  // Wait for testSpeedButtonPin press
    delay(500); // UX pause
  }
}


// E-Stop Handler
void handleEStopTriggered(bool inCalibration) {
  stopMotor(motorQSpeedPin);
  stopMotor(motorRSpeedPin);

  motorPosQ = 16;
  motorPosR = 16;

  clearAllLines();
  if (inCalibration) {
    drawLine(0, "E-Stop Activated!");
    drawLine(1, "Press SPEED Btn");
    drawLine(2, "to resume calibration");
    waitForResumeButton();
    delay(500); // UX pause
  } else {
    drawLine(0, "E-Stop Activated!");
    drawLine(1, "Recentering...");
    moveToCenter();

    motorPosQ = 16;
    motorPosR = 16;

    clearAllLines();
    drawLine(0, "E-Stop Cleared!");
    drawLine(1, "Press SPEED Btn");
    drawLine(2, "to resume motion");
    waitForResumeButton();
    delay(500); // UX pause
  }
}

//New function to allow the user to exit the safety modes - Estop, Boundary and manually return to the main loop. 
void waitForResumeButton() {
  // Wait for button release first (if already pressed)
  while (digitalRead(testSpeedButtonPin) == LOW) delay(10);
  // Wait for button press
  while (digitalRead(testSpeedButtonPin) == HIGH) delay(10);
  // Wait for release again for debounce
  while (digitalRead(testSpeedButtonPin) == LOW) delay(10);
}

// Move to Center Helper - new version in v42
void moveToCenter() {
  int center = 16;
  while (abs(mapEncoderToPosition(encoderQPosition, encoderQMin, encoderQMax, motorQPolarityReversed) - center) > 1 ||
         abs(mapEncoderToPosition(encoderRPosition, encoderRMin, encoderRMax, motorRPolarityReversed) - center) > 1) {
    
    // Q motor - use polarity-aware function
    int currentPosQ = mapEncoderToPosition(encoderQPosition, encoderQMin, encoderQMax, motorQPolarityReversed);
    bool moveUpQ = (center > currentPosQ);  // true if we need to move toward higher position numbers
    
    if (moveUpQ && digitalRead(motorQUpperLimitPin) == LOW) {
      moveMotorWithPolarity(motorQDirectionPin, motorQSpeedPin, true, 24, true);
    } else if (!moveUpQ && digitalRead(motorQLowerLimitPin) == LOW) {
      moveMotorWithPolarity(motorQDirectionPin, motorQSpeedPin, false, 24, true);
    } else {
      stopMotor(motorQSpeedPin);
    }
    
    // Same logic for R motor
    int currentPosR = mapEncoderToPosition(encoderRPosition, encoderRMin, encoderRMax, motorRPolarityReversed);
    bool moveUpR = (center > currentPosR);
    
    if (moveUpR && digitalRead(motorRUpperLimitPin) == LOW) {
      moveMotorWithPolarity(motorRDirectionPin, motorRSpeedPin, true, 24, false);
    } else if (!moveUpR && digitalRead(motorRLowerLimitPin) == LOW) {
      moveMotorWithPolarity(motorRDirectionPin, motorRSpeedPin, false, 24, false);
    } else {
      stopMotor(motorRSpeedPin);
    }
    
    delay(50);
  }
  stopMotor(motorQSpeedPin);
  stopMotor(motorRSpeedPin);
}


// Wait for A1 ("start lamp") serial command
void waitForStartLampCommand() {
  // Assume a global "startLampState" that is set true by serial processSerialCommand()
  while (!startLampState) delay(100);
}


//Settings Mode
void handleSettingsMode() {
  // Load latest settings (from RAM, which should match EEPROM already)
  float settings[numSettings] = {
    Kp, Ki, Kd, minPWMQ, maxPWMQ,
    KpR, KiR, KdR, minPWMR, maxPWMR,
    (float)emergencyStopEnabled,
    (float)boundarySensorEnabled,
    (float)cabinEStopEnabled
  };

  cursorPos = 0;
  clearAllLines();  // Only clear once at mode entry

  unsigned long lastUpdate = 0;
  bool edited = false;
  bool exitRequested = false;

  // Helper: Mark all lines as dirty, to force redraw
  for (int i = 0; i < 16; ++i) lastLines[i] = "";

  while (!exitRequested) {
    // Button reads
    bool leftFwdPressed = digitalRead(testLeftFwdPin) == LOW;
    bool leftRevPressed = digitalRead(testLeftRevPin) == LOW;
    bool rightFwdPressed = digitalRead(testRightFwdPin) == LOW;
    bool rightRevPressed = digitalRead(testRightRevPin) == LOW;
    bool saveExitPinState = digitalRead(settingsModeSwitchPin) == HIGH; // "Release" to save

    // Cursor movement (debounce)
    static bool lastLeftFwd = false, lastLeftRev = false;
    if (leftFwdPressed && !lastLeftFwd)  cursorPos = (cursorPos + 1) % numSettings;
    if (leftRevPressed && !lastLeftRev)  cursorPos = (cursorPos - 1 + numSettings) % numSettings;
    lastLeftFwd = leftFwdPressed;
    lastLeftRev = leftRevPressed;

    // Value editing (debounce)
    static bool lastRightFwd = false, lastRightRev = false;
    if (rightFwdPressed && !lastRightFwd) {
      if (cursorPos >= 10) settings[cursorPos] = 1; // ON for any of the three toggles
      else if ((cursorPos % 5) < 3) settings[cursorPos] += 0.1f; // PID
      else settings[cursorPos] += 10.0f; // PWM
      edited = true;
    }
    if (rightRevPressed && !lastRightRev) {
      if (cursorPos >= 10) settings[cursorPos] = 0; // OFF for any of the three toggles
      else if ((cursorPos % 5) < 3) settings[cursorPos] -= 0.1f; // PID
      else settings[cursorPos] -= 10.0f; // PWM
      edited = true;
    }
    lastRightFwd = rightFwdPressed;
    lastRightRev = rightRevPressed;

    // Clamp values to sensible ranges as they're edited
    settings[0]  = constrain(settings[0],  0.0, 100.0); // Q Kp
    settings[1]  = constrain(settings[1],  0.0, 100.0); // Q Ki
    settings[2]  = constrain(settings[2],  0.0, 100.0); // Q Kd
    settings[3]  = constrain(settings[3],  0, 255);     // Q minPWM
    settings[4]  = constrain(settings[4],  settings[3], 255); // Q maxPWM

    settings[5]  = constrain(settings[5],  0.0, 100.0); // R Kp
    settings[6]  = constrain(settings[6],  0.0, 100.0); // R Ki
    settings[7]  = constrain(settings[7],  0.0, 100.0); // R Kd
    settings[8]  = constrain(settings[8],  0, 255);     // R minPWM
    settings[9]  = constrain(settings[9],  settings[8], 255); // R maxPWM

    // OLED update (only draw what changes)
    if (millis() - lastUpdate > 120) {
      lastUpdate = millis();
      for (int i = 0; i < numSettings; ++i) {
        String label;
        switch (i) {
          case 0:  label = "Q Kp:"; break;
          case 1:  label = "Q Ki:"; break;
          case 2:  label = "Q Kd:"; break;
          case 3:  label = "Q minPWM:"; break;
          case 4:  label = "Q maxPWM:"; break;
          case 5:  label = "R Kp:"; break;
          case 6:  label = "R Ki:"; break;
          case 7:  label = "R Kd:"; break;
          case 8:  label = "R minPWM:"; break;
          case 9:  label = "R maxPWM:"; break;
          case 10: label = "EMERGENCY:"; break;
          case 11: label = "BOUNDARY:"; break;
          case 12: label = "CABIN E-STOP:"; break;
        }
        String val;
        if (i < 10 && !isnan(settings[i])) {
          val = String(settings[i], 2);
        } else if (i < 10 && isnan(settings[i])) {
          val = "ERR";
        } else {
          val = (settings[i] > 0.5 ? "ON" : "OFF");
        }
        drawLine(i, (i == cursorPos ? "> " : "  ") + label + " " + val);
      }
      if (!saveExitPinState) {
        drawLine(numSettings, "Set Pin6 HIGH to SAVE & EXIT");
      } else {
        drawLine(numSettings, "Saving & exiting...");
      }
    }

    // SAVE & EXIT if pin 6 goes HIGH ("released")
    if (saveExitPinState) {
      // Write settings to main variables
      Kp      = settings[0];
      Ki      = settings[1];
      Kd      = settings[2];
      minPWMQ = settings[3];
      maxPWMQ = settings[4];

      KpR     = settings[5];
      KiR     = settings[6];
      KdR     = settings[7];
      minPWMR = settings[8];
      maxPWMR = settings[9];

      emergencyStopEnabled  = settings[10] > 0.5;
      boundarySensorEnabled = settings[11] > 0.5;
      cabinEStopEnabled     = settings[12] > 0.5;

      // Save to EEPROM and update PID controllers
      saveSettings();
      pidQ.SetTunings(Kp, Ki, Kd);
      pidR.SetTunings(KpR, KiR, KdR);

      // Notify user
      clearAllLines();
      for (int countdown = 3; countdown > 0; --countdown) {
        drawLine(0, "Settings saved.");
        drawLine(1, "Re-entering main mode in " + String(countdown) + "...");
        delay(800);
      }
      clearAllLines();
      exitRequested = true;
    }

    delay(8); // Small delay for stability
  }

  // Settings saved, exit to main/calibration mode (do not call while loop again)
}





//EPROM Helpers for the Settings Menu
void writeFloat(int addr, float val) {
  byte* b = (byte*)(void*)&val;
  for (int i = 0; i < 4; i++) EEPROM.write(addr + i, b[i]);
}
float readFloat(int addr) {
  float val;
  byte* b = (byte*)(void*)&val;
  for (int i = 0; i < 4; i++) b[i] = EEPROM.read(addr + i);
  return val;
}

//Save Settings Function
void saveSettings() {
  writeFloat(ADDR_KpQ, Kp); 
  writeFloat(ADDR_KiQ, Ki); 
  writeFloat(ADDR_KdQ, Kd);
  writeFloat(ADDR_minPWMQ, minPWMQ); 
  writeFloat(ADDR_maxPWMQ, maxPWMQ);
  writeFloat(ADDR_KpR, KpR); 
  writeFloat(ADDR_KiR, KiR); 
  writeFloat(ADDR_KdR, KdR);
  writeFloat(ADDR_minPWMR, minPWMR); 
  writeFloat(ADDR_maxPWMR, maxPWMR);

  EEPROM.write(ADDR_emergencyStop, emergencyStopEnabled ? 1 : 0);
  EEPROM.write(ADDR_boundarySensorEnabled, boundarySensorEnabled ? 1 : 0);
  EEPROM.write(ADDR_cabinEStopEnabled, cabinEStopEnabled ? 1 : 0);
}

void loadSettings() {
  Kp = readFloat(ADDR_KpQ);
  if (isnan(Kp) || Kp < 0.0 || Kp > 100.0) Kp = 22.0;
  Ki = readFloat(ADDR_KiQ);
  if (isnan(Ki) || Ki < 0.0 || Ki > 100.0) Ki = 4.0;
  Kd = readFloat(ADDR_KdQ);
  if (isnan(Kd) || Kd < 0.0 || Kd > 100.0) Kd = 0.6;

  minPWMQ = readFloat(ADDR_minPWMQ);
  if (isnan(minPWMQ) || minPWMQ < 0.0 || minPWMQ > 255.0) minPWMQ = 80;
  maxPWMQ = readFloat(ADDR_maxPWMQ);
  if (isnan(maxPWMQ) || maxPWMQ < minPWMQ || maxPWMQ > 255.0) maxPWMQ = 255;

  KpR = readFloat(ADDR_KpR);
  if (isnan(KpR) || KpR < 0.0 || KpR > 100.0) KpR = 22.0;
  KiR = readFloat(ADDR_KiR);
  if (isnan(KiR) || KiR < 0.0 || KiR > 100.0) KiR = 3.5;
  KdR = readFloat(ADDR_KdR);
  if (isnan(KdR) || KdR < 0.0 || KdR > 100.0) KdR = 0.6;

  minPWMR = readFloat(ADDR_minPWMR);
  if (isnan(minPWMR) || minPWMR < 0.0 || minPWMR > 255.0) minPWMR = 80;
  maxPWMR = readFloat(ADDR_maxPWMR);
  if (isnan(maxPWMR) || maxPWMR < minPWMR || maxPWMR > 255.0) maxPWMR = 255;

  emergencyStopEnabled      = EEPROM.read(ADDR_emergencyStop) ? true : false;
  boundarySensorEnabled     = EEPROM.read(ADDR_boundarySensorEnabled) ? true : false;
  cabinEStopEnabled        = EEPROM.read(ADDR_cabinEStopEnabled) ? true : false;
}




// --------- TEST MODE ---------
void handleTestMode() {
  // Emergency Stop Handling (if global emergency flag is set)
  if (emergencyStopActivated) {
    stopMotor(motorQSpeedPin);
    stopMotor(motorRSpeedPin);
    clearAllLines();
    drawLine(0, "!!! EMERGENCY STOP !!!");
    return; // Skip test mode if emergency is active
  }

  // --- Read all button inputs ---
  bool leftFwdPressed  = digitalRead(testLeftFwdPin) == LOW;
  bool leftRevPressed  = digitalRead(testLeftRevPin) == LOW;
  bool rightFwdPressed = digitalRead(testRightFwdPin) == LOW;
  bool rightRevPressed = digitalRead(testRightRevPin) == LOW;
  bool currentSpeedBtnState = digitalRead(testSpeedButtonPin);

  // --- Read E-Stop and Boundary sensors (digital) ---
  bool estopButtonClosed = digitalRead(estopButtonPin) == LOW;          // D25
  bool boundaryTriggered = digitalRead(boundarySensorPin) == LOW;       // D27

  // --- Handle speed button toggle ---
  static bool lastSpeedBtnState = HIGH;
  if (lastSpeedBtnState == HIGH && currentSpeedBtnState == LOW) {
    incrementTestSpeed(); // Cycle through speed settings
  }
  lastSpeedBtnState = currentSpeedBtnState;
  int testSpeedPercent = testSpeedSetting * 14;

  // --- Toggle lamps every second for visual check ---
  static unsigned long lastToggle = 0;
  static bool lampState = false;
  if (millis() - lastToggle > 1000) {
    lastToggle = millis();
    lampState = !lampState;
    digitalWrite(startLampRelayPin, lampState ? HIGH : LOW);
    digitalWrite(dangerLampRelayPin, lampState ? HIGH : LOW);
  }

  // --- OLED & Serial Diagnostics (update every 250ms) ---
  if (millis() - lastDisplayUpdate > displayUpdateInterval) {
    lastDisplayUpdate = millis();

    drawLine(0,  "TEST MODE");

    // Limit switch status (Normally Closed = LOW, HIGH = triggered/open)
    drawLine(1,  "Q Lim U: " + String(digitalRead(motorQUpperLimitPin) == HIGH ? "TRIGGERED" : "CLEAR"));
    drawLine(2,  "Q Lim L: " + String(digitalRead(motorQLowerLimitPin) == HIGH ? "TRIGGERED" : "CLEAR"));
    drawLine(3,  "R Lim U: " + String(digitalRead(motorRUpperLimitPin) == HIGH ? "TRIGGERED" : "CLEAR"));
    drawLine(4,  "R Lim L: " + String(digitalRead(motorRLowerLimitPin) == HIGH ? "TRIGGERED" : "CLEAR"));

    // E-stop and Boundary
    drawLine(5, "E-STOP Btn: " + String(estopButtonClosed ? "CLOSED" : "OPEN!"));
    drawLine(6, "Boundary:   " + String(boundaryTriggered ? "TRIGGERED" : "CLEAR"));

    // Pot values (if used)
    drawLine(7,  "Q Pot: " + String(analogRead(potMotorQPin)));
    drawLine(8,  "R Pot: " + String(analogRead(potMotorRPin)));

    // Speed & input status
    drawLine(9,  "Test Speed: " + String(testSpeedPercent) + "%");
    drawLine(10, "Speed Btn: " + String(currentSpeedBtnState == LOW ? "PRESSED" : "RELEASED"));
    drawLine(11, "L FWD Btn: " + String(leftFwdPressed ? "ON" : "OFF"));
    drawLine(12, "L REV Btn: " + String(leftRevPressed ? "ON" : "OFF"));
    drawLine(13, "R FWD Btn: " + String(rightFwdPressed ? "ON" : "OFF"));
    drawLine(14, "R REV Btn: " + String(rightRevPressed ? "ON" : "OFF"));

    // Encoders for diagnostics
    drawLine(15, "Q Enc: " + String(encoderQPosition) + " | R: " + String(encoderRPosition));

    // --- Serial debug output for boundary sensor ---
    Serial.print("Boundary digital: ");
    Serial.println(digitalRead(boundarySensorPin));
  }

  // --- Manual motor control for left (Q) motor ---
  if (leftFwdPressed && !leftRevPressed) {
    moveMotor(motorQDirectionPin, HIGH, testSpeedPercent, motorQSpeedPin);
  } else if (leftRevPressed && !leftFwdPressed) {
    moveMotor(motorQDirectionPin, LOW, testSpeedPercent, motorQSpeedPin);
  } else if (leftFwdPressed && leftRevPressed) {
    moveMotor(motorQDirectionPin, HIGH, testSpeedPercent, motorQSpeedPin); // Default to forward if both pressed
  } else {
    stopMotor(motorQSpeedPin);
  }

  // --- Manual motor control for right (R) motor ---
  if (rightFwdPressed && !rightRevPressed) {
    moveMotor(motorRDirectionPin, HIGH, testSpeedPercent, motorRSpeedPin);
  } else if (rightRevPressed && !rightFwdPressed) {
    moveMotor(motorRDirectionPin, LOW, testSpeedPercent, motorRSpeedPin);
  } else if (rightFwdPressed && rightRevPressed) {
    moveMotor(motorRDirectionPin, HIGH, testSpeedPercent, motorRSpeedPin); // Default to forward if both pressed
  } else {
    stopMotor(motorRSpeedPin);
  }
}




// --------- SETUP & MAIN LOOP ---------
void setup() 
{
  // ---- Pin Setup ----
  pinMode(motorQDirectionPin, OUTPUT);
  pinMode(motorQSpeedPin, OUTPUT);
  pinMode(motorQLowerLimitPin, INPUT_PULLUP);
  pinMode(motorQUpperLimitPin, INPUT_PULLUP);

  pinMode(motorRDirectionPin, OUTPUT);
  pinMode(motorRSpeedPin, OUTPUT);
  pinMode(motorRLowerLimitPin, INPUT_PULLUP);
  pinMode(motorRUpperLimitPin, INPUT_PULLUP);

  pinMode(testModeSwitchPin, INPUT_PULLUP);
  pinMode(testLeftFwdPin, INPUT_PULLUP);
  pinMode(testLeftRevPin, INPUT_PULLUP);
  pinMode(testRightFwdPin, INPUT_PULLUP);
  pinMode(testRightRevPin, INPUT_PULLUP);
  pinMode(testSpeedButtonPin, INPUT_PULLUP);

  pinMode(settingsModeSwitchPin, INPUT_PULLUP);

  pinMode(motorQEnablePin, OUTPUT);
  pinMode(motorREnablePin, OUTPUT);
  digitalWrite(motorQEnablePin, LOW);
  digitalWrite(motorREnablePin, LOW);

  pinMode(encoderQPinA, INPUT_PULLUP);
  pinMode(encoderQPinB, INPUT_PULLUP);
  pinMode(encoderRPinA, INPUT_PULLUP);
  pinMode(encoderRPinB, INPUT_PULLUP);

  pinMode(startLampRelayPin, OUTPUT);
  pinMode(dangerLampRelayPin, OUTPUT);
  digitalWrite(startLampRelayPin, LOW);
  digitalWrite(dangerLampRelayPin, LOW);

  pinMode(estopButtonPin, INPUT_PULLUP);      // Assume NC loop, idle = LOW
  pinMode(boundarySensorPin, INPUT_PULLUP); // Enable internal pullup

  // ---- Serial and Display Setup ----
  Serial.begin(9600);
  tft.initR(INITR_BLACKTAB);
  tft.setRotation(1);
  tft.fillScreen(ST7735_BLACK);
  tft.setTextSize(1);
  tft.setTextColor(ST7735_WHITE);
  clearAllLines();

  // Rotary Encoders
  attachInterrupt(digitalPinToInterrupt(encoderQPinA), countEncoderQ, RISING);
  attachInterrupt(digitalPinToInterrupt(encoderRPinA), countEncoderR, RISING);

  // ---- Load settings from EEPROM ----
  loadSettings();
  clearAllLines();
  drawLine(0, "Settings loaded");
  delay(1200); // Display confirmation

  // ---- Update PID controllers with loaded values ----
  pidQ.SetTunings(Kp, Ki, Kd);
  pidR.SetTunings(KpR, KiR, KdR);
  pidQ.SetOutputLimits(0, 255);
  pidR.SetOutputLimits(0, 255);
  pidQ.SetSampleTime(10);
  pidR.SetSampleTime(10);
  pidQ.SetMode(AUTOMATIC);
  pidR.SetMode(AUTOMATIC);

  // ---- Enter Settings Mode if BOTH switches are LOW at Boot ----
  if (digitalRead(testModeSwitchPin) == LOW && digitalRead(settingsModeSwitchPin) == LOW) {
    clearAllLines();
    drawLine(0, "SETTINGS MODE");
    handleSettingsMode();

    // After handleSettingsMode() returns, reload settings and update PIDs:
    loadSettings();
    pidQ.SetTunings(Kp, Ki, Kd);
    pidR.SetTunings(KpR, KiR, KdR);
    clearAllLines();
    drawLine(0, "Settings loaded");
    delay(1200);
  }
  // ---- Otherwise enter Test Mode if only Test Switch is LOW ----
  else if (digitalRead(testModeSwitchPin) == LOW) {
    clearAllLines();
    drawLine(0, "Test mode on startup");
    if (DEBUG) Serial.println("[INFO] Test mode switch LOW – entering test mode...");
    while (true) {
      handleTestMode();
      delay(20);
    }
  }

  // ---- Limit Switch Sanity Check (for NC switches) ----
  if (digitalRead(motorQUpperLimitPin) == HIGH ||
      digitalRead(motorQLowerLimitPin) == HIGH ||
      digitalRead(motorRUpperLimitPin) == HIGH ||
      digitalRead(motorRLowerLimitPin) == HIGH) {
    clearAllLines();
    drawLine(0, "LIMIT SWITCH ERROR");
    drawLine(1, "Check Q UL: " + String(digitalRead(motorQUpperLimitPin)));
    drawLine(2, "Check Q LL: " + String(digitalRead(motorQLowerLimitPin)));
    drawLine(3, "Check R UL: " + String(digitalRead(motorRUpperLimitPin)));
    drawLine(4, "Check R LL: " + String(digitalRead(motorRLowerLimitPin)));
    drawLine(6, "Enter test mode to fix.");
    if (DEBUG) Serial.println("[ERROR] One or more limit switches are not NC. Halting.");
    while (true);
  }

  // ---- Begin Calibration ----
  clearAllLines();
  drawLine(0, "Running calibration...");
  if (DEBUG) Serial.println("[INFO] Starting calibration...");
  delay(1000);

  runCalibrationMode();

  // ---- Done ----
  clearAllLines();
  drawLine(0, "Ready (not test mode)");
  if (DEBUG) Serial.println("[INFO] Calibration complete. System ready.");
}

void runCalibrationMode() {
  clearAllLines();
  drawLine(0, "Starting Calibration");
  delay(1000);

  // Calibrate Left Motor
  if (!calibrateMotorWithSafety(
        "Left", motorQDirectionPin, motorQUpperLimitPin, motorQLowerLimitPin,
        motorQSpeedPin, true, encoderQMin, encoderQMax)) {
    // Calibration was halted by E-Stop; return immediately
    return;
  }

  // Calibrate Right Motor
  if (!calibrateMotorWithSafety(
        "Right", motorRDirectionPin, motorRUpperLimitPin, motorRLowerLimitPin,
        motorRSpeedPin, false, encoderRMin, encoderRMax)) {
    // Calibration was halted by E-Stop; return immediately
    return;
  }

  clearAllLines();
  drawLine(0, "Calibration Complete!");
  delay(1500);
}

bool calibrateMotorWithSafety(
    const char* label,
    int dirPin,
    int upLimitPin,
    int downLimitPin,
    int speedPin,
    bool isLeftMotor,
    long &encoderMin,
    long &encoderMax) 
{
  clearAllLines();
  drawLine(0, String("Calibrating ") + label);

  long* encoderPos = isLeftMotor ? &encoderQPosition : &encoderRPosition;

  // Step 1: Move to Lower Limit (REVERSE)
  drawLine(1, "Moving to BOTTOM...");

  moveMotorWithPolarity(dirPin, speedPin, false, 50, isLeftMotor);

  while (digitalRead(downLimitPin) == LOW) {
    // --- Safety Check: Cabin E-Stop ---
    if (cabinEStopEnabled && digitalRead(estopButtonPin) == LOW) {
      // PERMANENT HALT
      handleEStopTriggered(true);
      return false;
    }
    // --- Safety Check: Boundary Sensor ---
    while (boundarySensorEnabled && digitalRead(boundarySensorPin) == LOW) {
      handleBoundarySensorTriggered(true);
    }
    delay(5);
  }
  stopMotor(speedPin);
  encoderMin = *encoderPos;
  drawLine(2, "Bottom at: " + String(encoderMin));
  delay(200);

  // Back off slightly
  moveMotor(dirPin, DIR_FORWARD, 30, speedPin);
  delay(250);
  stopMotor(speedPin);
  delay(100);

  // Step 2: Move to Upper Limit (FORWARD)
  drawLine(3, "Moving to TOP...");
  moveMotor(dirPin, DIR_FORWARD, 50, speedPin);

  while (digitalRead(upLimitPin) == LOW) {
    if (cabinEStopEnabled && digitalRead(estopButtonPin) == LOW) {
      handleEStopTriggered(true);
      return false;
    }
    while (boundarySensorEnabled && digitalRead(boundarySensorPin) == LOW) {
      handleBoundarySensorTriggered(true);
    }
    delay(5);
  }
  stopMotor(speedPin);
  encoderMax = *encoderPos;
  drawLine(4, "Top at: " + String(encoderMax));
  delay(200);

  // Back off slightly
  moveMotor(dirPin, DIR_REVERSE, 30, speedPin);
  delay(250);
  stopMotor(speedPin);
  delay(100);

  // Step 3: Move to Midpoint
  long targetMid = (encoderMin + encoderMax) / 2;
  drawLine(5, "Moving to MID...");
  while (abs(*encoderPos - targetMid) > 3) {
    if (cabinEStopEnabled && digitalRead(estopButtonPin) == LOW) {
      handleEStopTriggered(true);
      return false;
    }
    while (boundarySensorEnabled && digitalRead(boundarySensorPin) == LOW) {
      handleBoundarySensorTriggered(true);
    }

    bool moveUp = encoderMax > encoderMin ? *encoderPos < targetMid : *encoderPos > targetMid;
    moveMotor(dirPin, moveUp ? DIR_FORWARD : DIR_REVERSE, 30, speedPin);
    delay(5);
  }
  stopMotor(speedPin);

  drawLine(6, "Midpoint OK");

  // --- Polarity and MapMin/Max Check (as before) ---
  bool reversed = encoderMin > encoderMax;
  int testMin = mapEncoderToPosition(encoderMin, encoderMin, encoderMax, reversed);
  int testMax = mapEncoderToPosition(encoderMax, encoderMin, encoderMax, reversed);

  if (testMin < testMax) {
    reversed = !reversed;
  }

  drawLine(9, "MapMin: " + String(mapEncoderToPosition(encoderMin, encoderMin, encoderMax, reversed)));
  drawLine(10, "MapMax: " + String(mapEncoderToPosition(encoderMax, encoderMin, encoderMax, reversed)));

  // Store polarity
  if (isLeftMotor) {
    motorQPolarityReversed = reversed;
  } else {
    motorRPolarityReversed = reversed;
  }

  drawLine(8, String(label) + " Cal OK");
  delay(1000);

  return true; // Success
}


int mapEncoderToPosition(long encoderVal, long minVal, long maxVal, bool reversed) {
  long bounded = constrain(encoderVal, min(minVal, maxVal), max(minVal, maxVal));
  if (reversed) {
    return map(bounded, minVal, maxVal, 32, 1);  // Invert mapping
  } else {
    return map(bounded, minVal, maxVal, 1, 32);   // Normal mapping
  }

  
}

void processSerialCommand(String input) {
  char cmd = input.charAt(0);
  int val = input.substring(1).toInt();

  lastSerialDataTime = millis();

  if (cmd == 'Q') {
    motorPosQ = val;
  }
  else if (cmd == 'R') {
    motorPosR = val;
  }
  else if (cmd == 'S') {
    motorSpeedQ = val;
  }
  else if (cmd == 'T') {
    motorSpeedR = val;
  }
  else if (cmd == 'A') { // Start Lamp
    startLampState = (val > 0);
    digitalWrite(startLampRelayPin, startLampState ? HIGH : LOW);
    // If Start Lamp turns ON, clear E-Stop lockout
    if (startLampState) {
      waitForStartLamp = false;
    }
  }
  else if (cmd == 'B') { // Danger Lamp
    dangerLampState = (val > 0);
    digitalWrite(dangerLampRelayPin, dangerLampState ? HIGH : LOW);
  }
  // Add additional serial command handling as required
}


void readSerialCommands() {
  static String inputString = "";
  while (Serial.available()) {
    char inChar = (char)Serial.read();

    // Ignore newline and carriage return characters
    if (inChar == '\n' || inChar == '\r') continue;

    if (inChar == 'x') {
      // Received complete message
      lastSerialDataTime = millis();

      // Ignore empty or malformed commands
      if (inputString.length() > 1) {
        if (inputString.equals("PING")) {
          // Heartbeat command – no action needed
          if (DEBUG) Serial.println("Heartbeat: PING received");
        } else {
          processSerialCommand(inputString);
        }
      }

      inputString = "";  // Always reset after terminator
    } else {
      inputString += inChar;

      // Flush buffer if it grows too large (possible garbage or missed 'x')
      if (inputString.length() > 20) {
        if (DEBUG) Serial.println("Flushing oversized input: " + inputString);
        inputString = "";
      }
    }
  }
}

void handleDriftCorrection() {
  static unsigned long lastResetTime = 0;
  const unsigned long resetCooldown = 300; // milliseconds

  if (millis() - lastResetTime < resetCooldown) return;

  // LEFT motor (Q)
  if (digitalRead(motorQLowerLimitPin) == HIGH && encoderQPosition != encoderQMin) {
    encoderQPosition = encoderQMin;
    if (DEBUG) Serial.println("[Q] Drift correction: Reset to encoderQMin");
    lastResetTime = millis();
  } else if (digitalRead(motorQUpperLimitPin) == HIGH && encoderQPosition != encoderQMax) {
    encoderQPosition = encoderQMax;
    if (DEBUG) Serial.println("[Q] Drift correction: Reset to encoderQMax");
    lastResetTime = millis();
  }

  // RIGHT motor (R)
  if (digitalRead(motorRLowerLimitPin) == HIGH && encoderRPosition != encoderRMin) {
    encoderRPosition = encoderRMin;
    if (DEBUG) Serial.println("[R] Drift correction: Reset to encoderRMin");
    lastResetTime = millis();
  } else if (digitalRead(motorRUpperLimitPin) == HIGH && encoderRPosition != encoderRMax) {
    encoderRPosition = encoderRMax;
    if (DEBUG) Serial.println("[R] Drift correction: Reset to encoderRMax");
    lastResetTime = millis();
  }
}

void checkTimeout() {
  if (millis() - lastSerialDataTime > serialTimeout) {
    motorPosQ = 16;
    motorPosR = 16;
    motorSpeedQ = 5;
    motorSpeedR = 5;
    if (DEBUG) Serial.println("Serial timeout — resetting targets.");
  }
}

void controlMotorToTarget(
  int dirPin,
  int speedPin,
  int upLimitPin,    // This should be the limit switch for position 1 (HIGH positions)
  int downLimitPin,  // This should be the limit switch for position 32 (LOW positions)  
  long currentEncoder,
  int targetPos,
  int speedPercent,
  long minEnc,
  long maxEnc,
  bool isLeft
) {
  bool reversed = isLeft ? motorQPolarityReversed : motorRPolarityReversed;
  int currentPos = mapEncoderToPosition(currentEncoder, minEnc, maxEnc, reversed);
  
  if (abs(currentPos - targetPos) <= 1) {
    stopMotor(speedPin);
    return;
  }

  // FIXED: Corrected the movement logic based on logic table
  bool needToMoveToLowerNumbers = currentPos > targetPos;  // Move toward position 1
  bool needToMoveToHigherNumbers = currentPos < targetPos; // Move toward position 32

  // FIXED: Check limits correctly based on position numbers, not encoder directions
  if (needToMoveToLowerNumbers && digitalRead(upLimitPin) == LOW) {
    // Moving toward position 1, check if upper limit (position 1 limit) is clear
    bool correctedDir = getCorrectedDirection(true, reversed);
    digitalWrite(dirPin, correctedDir ? HIGH : LOW);
    analogWrite(speedPin, speedPercent * 14);
  } 
  else if (needToMoveToHigherNumbers && digitalRead(downLimitPin) == LOW) {
    // Moving toward position 32, check if lower limit (position 32 limit) is clear  
    bool correctedDir = getCorrectedDirection(false, reversed);
    digitalWrite(dirPin, correctedDir ? HIGH : LOW);
    analogWrite(speedPin, speedPercent * 14);
  }
  else {
    stopMotor(speedPin);
  }

  if (DEBUG) {
    Serial.print(isLeft ? "Q" : "R");
    Serial.print(" | Curr: ");
    Serial.print(currentPos);
    Serial.print(" -> Target: ");
    Serial.print(targetPos);
    Serial.print(" | Need Lower: ");
    Serial.print(needToMoveToLowerNumbers);
    Serial.print(" | Need Higher: ");
    Serial.print(needToMoveToHigherNumbers);
    Serial.print(" | PWM: ");
    Serial.println(speedPercent * 14);
  }
}

void moveMotorPWM(int dirPin, int speedPWM, bool direction, int speedPin) {
  digitalWrite(dirPin, direction ? HIGH : LOW);
  analogWrite(speedPin, constrain(speedPWM, 0, 255));
}

// Modified boundary sensor handler - non-blocking version
void handleBoundarySensorActive() {
  // Stop all motors immediately
  stopMotor(motorQSpeedPin);
  stopMotor(motorRSpeedPin);
  
  // Set targets to center for safety
  motorPosQ = 16;
  motorPosR = 16;
  
  // Display boundary status
  clearAllLines();
  drawLine(0, "Boundary Triggered!");
  drawLine(1, "Motors stopped");
  drawLine(2, "Targets set to center");
  drawLine(3, "Waiting for clear...");
  
  // Show current positions for debugging
  int currentPosQ = mapEncoderToPosition(encoderQPosition, encoderQMin, encoderQMax, motorQPolarityReversed);
  int currentPosR = mapEncoderToPosition(encoderRPosition, encoderRMin, encoderRMax, motorRPolarityReversed);
  drawLine(4, "Current Q: " + String(currentPosQ));
  drawLine(5, "Current R: " + String(currentPosR));
}

// Function to handle boundary sensor clearing
void handleBoundarySensorCleared() {
  clearAllLines();
  drawLine(0, "Boundary Cleared!");
  drawLine(1, "Resuming normal");
  drawLine(2, "operation...");
  delay(1000); // Brief notification
  clearAllLines();
}

// Updated main loop function designed to ensure better handling of motor polarity. 
// Complete loop() function - REPLACE YOUR ENTIRE loop() FUNCTION WITH THIS:
// Complete loop() function - REPLACE YOUR ENTIRE loop() FUNCTION WITH THIS:
void loop() {
  readSerialCommands();
  checkTimeout();

  // Add emergency recovery check at the start
  emergencyLimitRecovery();

  // Determine if there is motion activity (recent serial commands)
  motionActive = (millis() - lastSerialDataTime < serialTimeout);

  // --- Cabin E-Stop Logic ---
  if (cabinEStopEnabled && digitalRead(estopButtonPin) == LOW && !eStopLatched) {
    handleEStopTriggered(false);
    eStopLatched = true;
    waitForStartLamp = true;
    return; // Everything else is blocked until reset
  }

  // --- E-Stop Recovery Mode ---
  if (eStopLatched) {
    // Check for speed button press (manual recovery)
    static bool lastSpeedBtnState = HIGH;
    bool currentSpeedBtnState = digitalRead(testSpeedButtonPin);
    
    if (lastSpeedBtnState == HIGH && currentSpeedBtnState == LOW) {
      // Speed button pressed - immediate recovery
      eStopLatched = false;
      waitForStartLamp = false;
      clearAllLines();
      drawLine(0, "E-Stop Cleared");
      drawLine(1, "(Manual Reset)");
      delay(1000);
      clearAllLines();
      lastSpeedBtnState = currentSpeedBtnState;
      // Continue to normal operation below
    } else if (!waitForStartLamp) {
      // Start Lamp command received - automatic recovery
      eStopLatched = false;
      clearAllLines();
      drawLine(0, "E-Stop Cleared");
      drawLine(1, "(Serial Reset)");
      delay(1000);
      clearAllLines();
      // Continue to normal operation below
    } else {
      // Still waiting for either reset method
      clearAllLines();
      drawLine(0, "E-Stop Active!");
      drawLine(1, "Press SPEED button");
      drawLine(2, "OR send Start Lamp");
      drawLine(3, "command to reset");
      lastSpeedBtnState = currentSpeedBtnState;
      delay(500);
      return;
    }
  }

  // --- NEW Boundary Sensor Logic ---
  bool boundarySensorTriggered = (digitalRead(boundarySensorPin) == LOW);
  
  if (boundarySensorEnabled && boundarySensorTriggered) {
    if (!boundaryHandlingActive) {
      // Boundary just triggered
      boundaryHandlingActive = true;
      boundaryTriggerTime = millis();
    }
    
    // Run boundary handling while sensor is triggered
    handleBoundarySensorActive();
    return; // Skip normal motor control while boundary is active
  } 
  else if (boundaryHandlingActive && !boundarySensorTriggered) {
    // Boundary sensor just cleared
    boundaryHandlingActive = false;
    handleBoundarySensorCleared();
    // Continue to normal operation below...
  }

  // --- Normal Motion Logic ---

  // Map encoder values to 1–32 scale
  inputQ = mapEncoderToPosition(encoderQPosition, encoderQMin, encoderQMax, motorQPolarityReversed);
  inputR = mapEncoderToPosition(encoderRPosition, encoderRMin, encoderRMax, motorRPolarityReversed);

  setpointQ = motorPosQ;
  setpointR = motorPosR;

  pidQ.Compute();
  pidR.Compute();

  int pwmQ = 0;
  int pwmR = 0;

  // --- FIXED Enhanced Safety lockout for limits with polarity awareness ---
  const int hysteresis = 1;
  bool leftBackoff = false;
  bool rightBackoff = false;

  // Left Motor Backoff Logic with Polarity Correction
  if (digitalRead(motorQLowerLimitPin) == HIGH) {
    // Lower limit triggered - need to move away from it toward position 1
    stopMotor(motorQSpeedPin);
    leftBackoff = true;
    
    // Force movement away from limit switch
    bool moveAwayDir = getCorrectedDirection(true, motorQPolarityReversed); // Move toward position 1 to get off lower limit
    moveMotor(motorQDirectionPin, moveAwayDir, 25, motorQSpeedPin); // Gentle backoff
    delay(100);
    stopMotor(motorQSpeedPin);
    
  } else if (digitalRead(motorQUpperLimitPin) == HIGH) {
    // Upper limit triggered - need to move away from it toward position 32
    stopMotor(motorQSpeedPin);
    leftBackoff = true;
    
    // Force movement away from limit switch
    bool moveAwayDir = getCorrectedDirection(false, motorQPolarityReversed); // Move toward position 32 to get off upper limit
    moveMotor(motorQDirectionPin, moveAwayDir, 25, motorQSpeedPin); // Gentle backoff
    delay(100);
    stopMotor(motorQSpeedPin);
    
  } else {
    leftBackoff = false;
  }

  // Right Motor Backoff Logic with Polarity Correction
  if (digitalRead(motorRLowerLimitPin) == HIGH) {
    // Lower limit triggered - need to move away from it toward position 1
    stopMotor(motorRSpeedPin);
    rightBackoff = true;
    
    // Force movement away from limit switch
    bool moveAwayDir = getCorrectedDirection(true, motorRPolarityReversed); // Move toward position 1 to get off lower limit
    moveMotor(motorRDirectionPin, moveAwayDir, 25, motorRSpeedPin); // Gentle backoff
    delay(100);
    stopMotor(motorRSpeedPin);
    
  } else if (digitalRead(motorRUpperLimitPin) == HIGH) {
    // Upper limit triggered - need to move away from it toward position 32
    stopMotor(motorRSpeedPin);
    rightBackoff = true;
    
    // Force movement away from limit switch  
    bool moveAwayDir = getCorrectedDirection(false, motorRPolarityReversed); // Move toward position 32 to get off upper limit
    moveMotor(motorRDirectionPin, moveAwayDir, 25, motorRSpeedPin); // Gentle backoff
    delay(100);
    stopMotor(motorRSpeedPin);
    
  } else {
    rightBackoff = false;
  }

  // Movement logic
  bool qShouldMove = (abs(inputQ - setpointQ) > hysteresis && !leftBackoff);
  bool rShouldMove = (abs(inputR - setpointR) > hysteresis && !rightBackoff);

  // CORRECTED: Simple movement logic - let's go back to basics
  bool moveQUp = (setpointQ > inputQ);    // Need to move to HIGHER position numbers
  bool moveQDown = (setpointQ < inputQ);  // Need to move to LOWER position numbers
  
  bool moveRUp = (setpointR > inputR);    // Need to move to HIGHER position numbers
  bool moveRDown = (setpointR < inputR);  // Need to move to LOWER position numbers

  // Q Motor movement - simplified logic
  if (qShouldMove) {
    pwmQ = constrain((int)outputQ + 120, minPWMQ, maxPWMQ);
    
    if (moveQUp && digitalRead(motorQLowerLimitPin) == LOW) {
      // Moving toward higher numbers (toward 32), check lower limit is clear
      digitalWrite(motorQDirectionPin, LOW);  // Try this direction first
      analogWrite(motorQSpeedPin, pwmQ);
    }
    else if (moveQDown && digitalRead(motorQUpperLimitPin) == LOW) {
      // Moving toward lower numbers (toward 1), check upper limit is clear
      digitalWrite(motorQDirectionPin, HIGH); // Try this direction first
      analogWrite(motorQSpeedPin, pwmQ);
    }
    else {
      stopMotor(motorQSpeedPin);
      pwmQ = 0;
    }
  } else {
    stopMotor(motorQSpeedPin);
    pwmQ = 0;
  }

  // R Motor movement - simplified logic
  if (rShouldMove) {
    pwmR = constrain((int)outputR + 120, minPWMR, maxPWMR);
    
    if (moveRUp && digitalRead(motorRLowerLimitPin) == LOW) {
      // Moving toward higher numbers (toward 32), check lower limit is clear
      digitalWrite(motorRDirectionPin, LOW);  // Try this direction first
      analogWrite(motorRSpeedPin, pwmR);
    }
    else if (moveRDown && digitalRead(motorRUpperLimitPin) == LOW) {
      // Moving toward lower numbers (toward 1), check upper limit is clear
      digitalWrite(motorRDirectionPin, HIGH); // Try this direction first
      analogWrite(motorRSpeedPin, pwmR);
    }
    else {
      stopMotor(motorRSpeedPin);
      pwmR = 0;
    }
  } else {
    stopMotor(motorRSpeedPin);
    pwmR = 0;
  }

  // --- OLED feedback ---
  drawLine(0, "Target Q: " + String(setpointQ));
  drawLine(1, "Target R: " + String(setpointR));
  drawLine(2, "Mapped Q: " + String(inputQ));
  drawLine(3, "Mapped R: " + String(inputR));
  drawLine(4, "Output Q: " + String(outputQ));
  drawLine(5, "Output R: " + String(outputR));
  drawLine(6, "Q Move? " + String(qShouldMove ? "YES" : "NO"));
  drawLine(7, "R Move? " + String(rShouldMove ? "YES" : "NO"));
  drawLine(8, "Serial: " + String((millis() - lastSerialDataTime < serialTimeout) ? "ACTIVE" : "TIMEOUT"));
  drawLine(9, "PWM Q: " + String(pwmQ));
  drawLine(10, "PWM R: " + String(pwmR));
  drawLine(11, "Start Lamp: " + String(startLampState ? "ON" : "OFF"));
  drawLine(12, "Danger Lamp: " + String(dangerLampState ? "ON" : "OFF"));
  drawLine(13, "Boundary: " +
    String(digitalRead(boundarySensorPin) == LOW ? "TRIGGERED" : "CLEAR") +
    (boundaryHandlingActive ? " (ACTIVE)" : ""));
  drawLine(14, "E-Stop Btn: " +
    String(digitalRead(estopButtonPin) == LOW ? "PRESSED" : "OK") +
    (eStopLatched ? " (LOCKED)" : ""));
  drawLine(15, "E-Stop State: " +
    String(eStopLatched ? "TRIGGERED" : "READY"));

  handleDriftCorrection();
}
